/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ISynthPluginAudioProcessor::ISynthPluginAudioProcessor()
{
    UserParams[SliderOsc]=0.0;
    UserParams[SliderOsc1]=0.0;
    UserParams[ByPass]=0.0;
    UserParams[ByPass1]=0.0;
    UserParams[ByPass2]=0.0;
    UserParams[ByPass3]=0.0;
    UserParams[ByPass4]=0.0;
    UserParams[cof]=0.99;
    UserParams[res]=0.0;
    UserParams[lfoFreq]=6.0;
    UserParams[lfoFreq]=0.1;
}

ISynthPluginAudioProcessor::~ISynthPluginAudioProcessor()
{
    UserParams[SliderOsc]=0.0;
    UserParams[SliderOsc1]=0.0;
    UserParams[ByPass]=0.0;
    UserParams[ByPass1]=0.0;
    UserParams[ByPass2]=0.0;
    UserParams[ByPass3]=0.0;
    UserParams[ByPass4]=0.0;
    UserParams[cof]=0.99;
    UserParams[res]=0.0;
    UserParams[lfoFreq]=6.0;
    UserParams[lfoFreq]=0.1;
}

//==============================================================================
const String ISynthPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int ISynthPluginAudioProcessor::getNumParameters()
{
    return totalNumParam;
}

/*chiamata dall'host quando muovo un parametro*/
float ISynthPluginAudioProcessor::getParameter (int index)
{
    switch (index) {
        case SliderOsc:
            return UserParams[SliderOsc];
        case SliderOsc1:
            return UserParams[SliderOsc1];
        case ByPass:
            return UserParams[ByPass];
        case ByPass1:
            return UserParams[ByPass1];
        case oscMode:
            return UserParams[oscMode];
        case oscMode1:
            return UserParams[oscMode1];
        case envA:
            return UserParams[envA];
        case envD:
            return UserParams[envD];
        case envS:
            return UserParams[envS];
        case envR:
            return UserParams[envR];
        case cof:
            return UserParams[cof];
        case res:
            return UserParams[res];
        case ByPass2:
            return UserParams[ByPass2];
        case filMode:
            return UserParams[filMode];
        case ByPass3:
            return UserParams[ByPass3];
        case lfoFreq:
            return UserParams[lfoFreq];
        case lfoFilterModAmount:
            return UserParams[lfoFilterModAmount];
        case lfoMode:
            return UserParams[lfoMode];
        case lfoMode2:
            return UserParams[lfoMode2];
        case ByPass4:
            return UserParams[ByPass4];
        case midiMSG:
            return UserParams[midiMSG];
        case seqMode:
            return UserParams[seqMode];
        case sliderSeq:
            return UserParams[sliderSeq];
        default:
             return 0.0f;
    }
}

void ISynthPluginAudioProcessor::setParameter (int index, float newValue)
{
    switch (index) {
        case SliderOsc:
            UserParams[SliderOsc]=newValue;
            synth.setFrequency(newValue);
        break;
        case SliderOsc1:
            UserParams[SliderOsc1]=newValue;
            synth.setFrequency1(newValue);
        break;
        case ByPass:
            UserParams[ByPass]=newValue;
            synth.setBypass((int)newValue);
        break;
        case ByPass1:
            UserParams[ByPass1]=newValue;
            synth.setBypass1((int)newValue);
        break;
        case oscMode:
            UserParams[oscMode]=newValue;
            synth.setSynthMode((int)newValue);
        break;
        case oscMode1:
            UserParams[oscMode1]=newValue;
            synth.setSynthMode1((int)newValue);
        break;
        case envA:
            UserParams[envA]=newValue;
            synth.setEnvA(newValue);
        break;
        case envD:
            UserParams[envD]=newValue;
            synth.setEnvD(newValue);
        break;
        case envS:
            UserParams[envS]=newValue;
            synth.setEnvS(newValue);
        break;
        case envR:
            UserParams[envR]=newValue;
            synth.setEnvR(newValue);
        break;
        case cof:
            UserParams[cof]=newValue;
            synth.setCof(newValue);
        break;
        case res:
            UserParams[res]=newValue;
            synth.setRes(newValue);
        break;
        case ByPass2:
            UserParams[ByPass2]=newValue;
            synth.setBypass2((int)newValue);
        break;
        case filMode:
            UserParams[filMode]=newValue;
            synth.setFilMode((int)newValue);
        break;
        case ByPass3:
            UserParams[ByPass3]=newValue;
            synth.setBypass3((int)newValue);
        break;
        case lfoFreq:
            UserParams[lfoFreq]=newValue;
            synth.setFrequencyLFO(newValue);
            break;
        case lfoFilterModAmount:
            UserParams[lfoFilterModAmount]=newValue;
            synth.setFrequencyMod(newValue);
            break;
        case lfoMode:
            UserParams[lfoMode]=newValue;
            synth.setLFOMode(newValue);
            break;
        case lfoMode2:
            UserParams[lfoMode2]=newValue;
            synth.setLFOMode2(newValue);
            break;
        case ByPass4:
            UserParams[ByPass4]=newValue;
            synth.setBypass4((int)newValue);
        case midiMSG:
            UserParams[midiMSG]=newValue;
        case seqMode:
            UserParams[seqMode]=newValue;
            synth.setSeqMode(newValue);
            break;
        case sliderSeq:
            UserParams[sliderSeq]=newValue;
            synth.setBPM(newValue);
            break;
        default:
            return;
    }
}

const String ISynthPluginAudioProcessor::getParameterName (int index)
{
      switch (index) {
         case SliderOsc:
            return "SliderOsc1"; 
         case SliderOsc1:
            return "SliderOsc2";
         case ByPass:
              return "ByPass";
         case ByPass1:
              return "ByPass1";
         case oscMode:
              return "OscMode";
         case oscMode1:
              return "OscMode1";
         case envA:
              return "envA";
         case envD:
              return "envD";
         case envS:
              return "envS";
         case envR:
              return "envR";
         case cof:
              return "cof";
         case res:
              return "res";
          case ByPass3:
              return "ByPass3";
         case ByPass2:
              return "ByPass2";
         case filMode:
              return "filMode";
          case lfoFreq:
              return "lfoFreq";
          case lfoFilterModAmount:
              return "lfoFilterModAmount";
          case lfoMode:
              return "lfoMode";
          case lfoMode2:
              return "lfoMode2";
          case ByPass4:
              return "ByPass4";
          case midiMSG:
              return "midiMSG";
          case seqMode:
              return "seqMode";
          case sliderSeq:
              return "sliderSeq";
         default:
            return String::empty;
    }
}

const String ISynthPluginAudioProcessor::getParameterText (int index)
{
     switch (index) {
         case SliderOsc:
             return String(UserParams[SliderOsc],3);
             break;
         case SliderOsc1:
             return String(UserParams[SliderOsc1],3);
             break;
         case ByPass:
             return String(UserParams[ByPass],3);
         case ByPass1:
             return String(UserParams[ByPass1],3);
         case oscMode:
             return String(UserParams[oscMode],3);
         case oscMode1:
             return String(UserParams[oscMode1],3);
         case envA:
             return String(UserParams[envA],3);
         case envD:
             return String(UserParams[envD],3);
         case envS:
             return String(UserParams[envS],3);
         case envR:
             return String(UserParams[envR],3);
         case cof:
             return String(UserParams[cof],3);
         case res:
             return String(UserParams[res],3);
         case ByPass2:
             return String(UserParams[ByPass2],3);
         case ByPass3:
             return String(UserParams[ByPass3],3);
         case filMode:
             return String(UserParams[filMode],3);
         case lfoFreq:
             return String(UserParams[lfoFreq],3);
         case lfoFilterModAmount:
             return String(UserParams[lfoFilterModAmount],3);
         case lfoMode:
             return String(UserParams[lfoMode],3);
         case lfoMode2:
             return String(UserParams[lfoMode2],3);
         case ByPass4:
             return String(UserParams[ByPass4],3);
         case midiMSG:
             return String(UserParams[midiMSG],3);
         case sliderSeq:
             return String(UserParams[sliderSeq],3);
         case seqMode:
             return String(UserParams[seqMode],3);
         default:
             break;
    } 
    return String::empty;
}

const String ISynthPluginAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ISynthPluginAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ISynthPluginAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ISynthPluginAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ISynthPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ISynthPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ISynthPluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double ISynthPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ISynthPluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ISynthPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void ISynthPluginAudioProcessor::setCurrentProgram (int index)
{
}

const String ISynthPluginAudioProcessor::getProgramName (int index)
{
    return String();
}

void ISynthPluginAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ISynthPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void ISynthPluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void ISynthPluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    float* leftData = buffer.getWritePointer(0); //ritorna un puntatore scrivibile ad uno dei canali del buffer
    float* rightData = buffer.getWritePointer(1);
    
    /*midiMessages verrà riempito con i messaggi midi per questo block*/
    MidiMessage message (0);
    MidiBuffer::Iterator i (midiMessages); //creo un iterator per il mio MidiBuffer
    int messageFrameRelativeTothisProcess; //posizione campione nel buffer
    
    while (i.getNextEvent (message, messageFrameRelativeTothisProcess)) //prende una copia del prossimo evento dal buffer, torna true se trova un evento
    {
        if (message.isNoteOn())
        {
            synth.setFrequency((float)(440.0 * pow(2.0, (message.getNoteNumber() - 69.0)/12.0)));
            synth.setFrequency1((float)(440.0 * pow(2.0, (message.getNoteNumber() - 69.0)/12.0)));
            if(UserParams[seqMode]==3)
            {
                synth.setFrequency((float)(440.0 * pow(2.0, (message.getNoteNumber() - 69.0)/12.0)));
                synth.rec((float)(440.0 * pow(2.0, (message.getNoteNumber() - 69.0)/12.0)));
            }
        }
        if(message.isNoteOff())
             synth.setFrequency(0.0);
    }
    for (long i = 0; i < buffer.getNumSamples(); i++)
        synth.myProcess(&leftData[i], &rightData[i],message.getNoteNumber());
}

//==============================================================================
bool ISynthPluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ISynthPluginAudioProcessor::createEditor()
{
    return new ISynthPluginAudioProcessorEditor (this);
}

//==============================================================================
void ISynthPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void ISynthPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin.. MODIFICATO !!!
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ISynthPluginAudioProcessor();
}
